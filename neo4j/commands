# TODO
- Cambiar los horarios por timestamps y agregar una columna 'duracion'
- Eliminar las columnas de iata_codes y distancia recorrida

# Desactivar el auto-complete para que el grafo resultante sea la solución
# Ir a Browser Settings - Destildar "Connect result nodes"

# Limpiar la base de datos
MATCH (n) DETACH DELETE n

# Importar CSV al neo4j y crear los nodos y relaciones a partir de esto
# Primero, ubicar el archivo csv en la carpeta import de la database
LOAD CSV WITH HEADERS FROM "file:///small_info_vuelos_full.csv" AS vuelos
MERGE (a:Ciudad { nombre: vuelos.origen })
MERGE (b:Ciudad { nombre: vuelos.destino })
MERGE (a)-[:VUELO {	aerolinea: vuelos.aerolinea,
					fecha_salida: vuelos.fecha_salida,
					horario_salida: vuelos.horario_salida,
					fecha_llegada: vuelos.fecha_llegada,
					horario_llegada: vuelos.horario_llegada,
					precio: vuelos.precio,
					asientos: vuelos.asientos_dispobiles
					}]->(b)

# Mostrar la base de datos
MATCH (n) RETURN n

# Instalar la librería APOC (contiene algoritmos de grafos)
# Ir a la database en neo4j - plugins, instalar

# Algoritmo de dijkstra
MATCH (start: Ciudad {nombre: 'Arequipa'}), (end: Ciudad {nombre: 'Lima'})
CALL apoc.algo.dijkstra(start, end, 'VUELO', 'precio')
YIELD path, weight AS precio
RETURN path, precio

# Ir acumulando precios para no pasarme de un limite
WITH 'Arequipa' AS origen, 'Lima' AS destino, 300 AS costo_limite
MATCH path=(start: Ciudad {nombre: origen})-[vuelos:VUELO*]->(end: Ciudad {nombre: destino})
WITH path, REDUCE(weight = 0, vuelo in vuelos | weight + vuelo.precio) as precio
WHERE toFloat(precio) <= costo_limite
RETURN path, toFloat(precio)
ORDER BY precio ASC
LIMIT 1

# Aplicar condicion sobre los vuelos obtenidos en el path
WITH 'Arequipa' AS origen, 'Lima' AS destino, 300 AS max_costo, 2 AS min_asientos
MATCH path = allShortestPaths((a:Ciudad {nombre: origen})-[vuelos:VUELO*]->(b:Ciudad {nombre: destino}))
WHERE ALL (vuelo in vuelos WHERE toInt(vuelo.asientos) >= min_asientos)
RETURN path

# Comparar relaciones dentro del path (para asegurarme que los vuelos salgan en orden)
WITH 'Arequipa' AS origen, 'Lima' AS destino, 300 AS max_costo, 2 AS min_asientos
MATCH path = (a:Ciudad {nombre: origen})-[v1:VUELO]-()-[v2:VUELO]->(b:Ciudad {nombre: destino})
WHERE v1.horario_llegada < v2.horario_salida
RETURN path
