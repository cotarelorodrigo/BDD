# TODO
- Cambiar los horarios por timestamps y agregar una columna 'duracion'
- Ver como poner la condicion de horario_salida(n+1) > horario_llegada(n)
- Ver como ir acumulando el precio y comprobar que no se pase del limite


# Limpiar la base de datos
MATCH (n) DETACH DELETE n

# Importar CSV al neo4j y crear los nodos y relaciones a partir de esto
# Primero, ubicar el archivo csv en la carpeta import de la database
LOAD CSV WITH HEADERS FROM "file:///small_info_vuelos_full.csv" AS vuelos
MERGE (a:Ciudad { nombre: vuelos.origen })
MERGE (b:Ciudad { nombre: vuelos.destino })
MERGE (a)-[:VUELO {	aerolinea: vuelos.aerolinea,
					fecha_salida: vuelos.fecha_salida,
					horario_salida: vuelos.horario_salida,
					fecha_llegada: vuelos.fecha_llegada,
					horario_llegada: vuelos.horario_llegada,
					precio: vuelos.precio,
					asientos: vuelos.asientos_dispobiles
					}]->(b)

# Mostrar la base de datos
MATCH (n) RETURN n

# Instalar la librerÃ­a APOC (contiene algoritmos de grafos)
# Ir a la database en neo4j - plugins, instalar

# Algoritmo de dijkstra
MATCH (start: Ciudad {nombre: 'Arequipa'}), (end: Ciudad {nombre: 'Lima'})
CALL apoc.algo.dijkstra(start, end, 'VUELO', 'precio')
YIELD path, weight AS precio
RETURN path, precio

# Version con cypher pura (algo asi)
MATCH p=(start:Point {title: 'Some Point 1'})-[rels:distance*]->(end:Point {title: 'Some Point 5'})
WITH p, REDUCE(weight=0, rel in rels | weight + rel.value) as length
RETURN p, length 
ORDER BY length ASC
LIMIT 10

# Aplicar condicion sobre la relacion (vuelos)
# Hay que asignarle un alias a la relacion
# Asientos disponibles >= n
WHERE vuelos.asientos >= n

# Costo <= n
WHERE vuelos.cost <= n
